// Code generated by the Encore v1.52.2 client generator. DO NOT EDIT.

// Disable eslint, jshint, and jslint for this file.
/* eslint-disable */
/* jshint ignore:start */
/*jslint-disable*/

/**
 * BaseURL is the base URL for calling the Encore application's API.
 */
export type BaseURL = string

export const Local: BaseURL = "http://localhost:4000"

/**
 * Environment returns a BaseURL for calling the cloud environment with the given name.
 */
export function Environment(name: string): BaseURL {
    return `https://${name}-dat-attendance-q9vi.encr.app`
}

/**
 * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.
 */
export function PreviewEnv(pr: number | string): BaseURL {
    return Environment(`pr${pr}`)
}

const BROWSER = typeof globalThis === "object" && ("window" in globalThis);

/**
 * Client is an API client for the dat-attendance-q9vi Encore application.
 */
export default class Client {
    public readonly hello: hello.ServiceClient
    public readonly app: app.ServiceClient
    public readonly auth: auth.ServiceClient
    public readonly dev_tools: dev_tools.ServiceClient
    public readonly notification: notification.ServiceClient
    private readonly options: ClientOptions
    private readonly target: string


    /**
     * Creates a Client for calling the public and authenticated APIs of your Encore application.
     *
     * @param target  The target which the client should be configured to use. See Local and Environment for options.
     * @param options Options for the client
     */
    constructor(target: BaseURL, options?: ClientOptions) {
        this.target = target
        this.options = options ?? {}
        const base = new BaseClient(this.target, this.options)
        this.hello = new hello.ServiceClient(base)
        this.app = new app.ServiceClient(base)
        this.auth = new auth.ServiceClient(base)
        this.dev_tools = new dev_tools.ServiceClient(base)
        this.notification = new notification.ServiceClient(base)
    }

    /**
     * Creates a new Encore client with the given client options set.
     *
     * @param options Client options to set. They are merged with existing options.
     **/
    public with(options: ClientOptions): Client {
        return new Client(this.target, {
            ...this.options,
            ...options,
        })
    }
}

/**
 * ClientOptions allows you to override any default behaviour within the generated Encore client.
 */
export interface ClientOptions {
    /**
     * By default the client will use the inbuilt fetch function for making the API requests.
     * however you can override it with your own implementation here if you want to run custom
     * code on each API request made or response received.
     */
    fetcher?: Fetcher

    /** Default RequestInit to be used for the client */
    requestInit?: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }

    /**
     * Allows you to set the authentication data to be used for each
     * request either by passing in a static object or by passing in
     * a function which returns a new object for each request.
     */
    auth?: auth.AuthParams | AuthDataGenerator
}

export namespace hello {
    export interface Response {
        message: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.get = this.get.bind(this)
        }

        /**
         * This is a simple REST API that responds with a personalized greeting.
         * To call it, run in your terminal:
         * curl http://localhost:4000/hello/World
         */
        public async get(name: string): Promise<Response> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/hello/${encodeURIComponent(name)}`)
            return await resp.json() as Response
        }
    }
}

export namespace app {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.admin_clock = this.admin_clock.bind(this)
            this.admin_get_attendance = this.admin_get_attendance.bind(this)
            this.admin_get_attendance_summary = this.admin_get_attendance_summary.bind(this)
            this.admin_get_user_attendance_detail = this.admin_get_user_attendance_detail.bind(this)
            this.admin_get_user_today = this.admin_get_user_today.bind(this)
            this.admin_update_attendance = this.admin_update_attendance.bind(this)
            this.admin_verify_qr_token = this.admin_verify_qr_token.bind(this)
            this.change_password = this.change_password.bind(this)
            this.change_user_status = this.change_user_status.bind(this)
            this.clock_in = this.clock_in.bind(this)
            this.clock_out = this.clock_out.bind(this)
            this.create_user = this.create_user.bind(this)
            this.delete_avatar = this.delete_avatar.bind(this)
            this.delete_face = this.delete_face.bind(this)
            this.delete_user = this.delete_user.bind(this)
            this.force_logout = this.force_logout.bind(this)
            this.generate_qr_token = this.generate_qr_token.bind(this)
            this.get_active_qr_token = this.get_active_qr_token.bind(this)
            this.get_clock_methods = this.get_clock_methods.bind(this)
            this.get_face_status = this.get_face_status.bind(this)
            this.get_my_attendance = this.get_my_attendance.bind(this)
            this.get_profile = this.get_profile.bind(this)
            this.get_today_status = this.get_today_status.bind(this)
            this.get_user_detail = this.get_user_detail.bind(this)
            this.get_user_sessions = this.get_user_sessions.bind(this)
            this.list_roles = this.list_roles.bind(this)
            this.list_users = this.list_users.bind(this)
            this.public_verify_face = this.public_verify_face.bind(this)
            this.public_verify_qr_token = this.public_verify_qr_token.bind(this)
            this.register_face = this.register_face.bind(this)
            this.reset_password = this.reset_password.bind(this)
            this.restore_user = this.restore_user.bind(this)
            this.update_profile = this.update_profile.bind(this)
            this.update_user = this.update_user.bind(this)
            this.update_user_role = this.update_user_role.bind(this)
            this.upload_avatar = this.upload_avatar.bind(this)
            this.verify_face_and_clock = this.verify_face_and_clock.bind(this)
        }

        public async admin_clock(params: attendance.AdminClockRequest): Promise<attendance.ClockResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/admin/attendance/clock`, JSON.stringify(params))
            return await resp.json() as attendance.ClockResponse
        }

        public async admin_get_attendance(params: attendance.GetAdminAttendanceRequest): Promise<attendance.AttendanceListResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                from:      params.from,
                limit:     params.limit === undefined ? undefined : String(params.limit),
                offset:    params.offset === undefined ? undefined : String(params.offset),
                to:        params.to,
                type:      params.type === undefined ? undefined : String(params.type),
                "user_id": params["user_id"],
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/admin/attendance`, undefined, {query})
            return await resp.json() as attendance.AttendanceListResponse
        }

        /**
         * [管理者] ユーザー勤怠サマリー一覧を取得
         */
        public async admin_get_attendance_summary(): Promise<attendance.UserAttendanceSummaryListResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/admin/attendance/summary`)
            return await resp.json() as attendance.UserAttendanceSummaryListResponse
        }

        public async admin_get_user_attendance_detail(user_id: string, params: attendance.GetUserAttendanceDetailRequest): Promise<attendance.UserAttendanceDetailResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                month: params.month === undefined ? undefined : String(params.month),
                year:  params.year === undefined ? undefined : String(params.year),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/admin/attendance/user/${encodeURIComponent(user_id)}`, undefined, {query})
            return await resp.json() as attendance.UserAttendanceDetailResponse
        }

        public async admin_get_user_today(user_id: string): Promise<attendance.TodayStatus> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/admin/attendance/today/${encodeURIComponent(user_id)}`)
            return await resp.json() as attendance.TodayStatus
        }

        /**
         * [管理者] 打刻を修正
         */
        public async admin_update_attendance(id: string, params: attendance.UpdateAttendanceRequest): Promise<{
    record: attendance.AttendanceRecord
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/admin/attendance/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as {
    record: attendance.AttendanceRecord
}
        }

        /**
         * [管理者] QRトークンを検証して打刻を行う
         */
        public async admin_verify_qr_token(params: attendance.VerifyQRTokenRequest): Promise<attendance.VerifyQRTokenResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/admin/attendance/qr/verify`, JSON.stringify(params))
            return await resp.json() as attendance.VerifyQRTokenResponse
        }

        /**
         * 公開API: 自分のパスワード変更
         * - 現在のパスワードをauthで検証 → 新パスワードハッシュをauthへ保存。
         * - new_passwordは8文字以上を要求。
         */
        public async change_password(params: users.ChangePasswordRequest): Promise<{
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/user-settings/change-password`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
}
        }

        /**
         * 公開API: アクティブ/非アクティブ切替（SUPER_ADMINのみ）
         */
        public async change_user_status(userId: string, params: {
    /**
     * 公開API: アクティブ/非アクティブ切替（SUPER_ADMINのみ）
     */
    isActive: boolean
}): Promise<{
    /**
     * 公開API: アクティブ/非アクティブ切替（SUPER_ADMINのみ）
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/${encodeURIComponent(userId)}/status`, JSON.stringify(params))
            return await resp.json() as {
    /**
     * 公開API: アクティブ/非アクティブ切替（SUPER_ADMINのみ）
     */
    success: boolean
}
        }

        /**
         * 出勤打刻
         */
        public async clock_in(params: attendance.ClockRequest): Promise<attendance.ClockResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/attendance/clock-in`, JSON.stringify(params))
            return await resp.json() as attendance.ClockResponse
        }

        /**
         * 退勤打刻
         */
        public async clock_out(params: attendance.ClockRequest): Promise<attendance.ClockResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/attendance/clock-out`, JSON.stringify(params))
            return await resp.json() as attendance.ClockResponse
        }

        /**
         * 公開API: 新規ユーザー作成（管理者以上）
         * - users: app_users INSERT、auth: auth_users 作成。
         * - TODO: email必須/形式・password長(>=8)の検証を追加（tests要件あり）。
         */
        public async create_user(params: {
    email: string
    password: string
    displayName: string
    firstName?: string
    lastName?: string
    firstNameRomaji?: string
    lastNameRomaji?: string
    timezone?: string
    language?: string
    roleName?: string
}): Promise<{
    userId: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users`, JSON.stringify(params))
            return await resp.json() as {
    userId: string
}
        }

        /**
         * 公開API: アバター削除
         */
        public async delete_avatar(): Promise<{
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/user-settings/avatar`)
            return await resp.json() as {
    success: boolean
}
        }

        public async delete_face(face_id: string): Promise<attendance.DeleteFaceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/attendance/face/${encodeURIComponent(face_id)}`)
            return await resp.json() as attendance.DeleteFaceResponse
        }

        /**
         * 公開API: ユーザー削除（論理削除, 管理者以上）
         * - FIXME: 自分自身の削除禁止チェックが未実装（testsにも要件あり）。
         * - FIXME: ログの `auth.getAuthData()` 呼び出しは誤り。`getAuthData()` を使用すること。
         */
        public async delete_user(userId: string): Promise<{
    /**
     * 公開API: ユーザー削除（論理削除, 管理者以上）
     * - FIXME: 自分自身の削除禁止チェックが未実装（testsにも要件あり）。
     * - FIXME: ログの `auth.getAuthData()` 呼び出しは誤り。`getAuthData()` を使用すること。
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/users/${encodeURIComponent(userId)}`)
            return await resp.json() as {
    /**
     * 公開API: ユーザー削除（論理削除, 管理者以上）
     * - FIXME: 自分自身の削除禁止チェックが未実装（testsにも要件あり）。
     * - FIXME: ログの `auth.getAuthData()` 呼び出しは誤り。`getAuthData()` を使用すること。
     */
    success: boolean
}
        }

        /**
         * 公開API: 全セッション無効化（強制ログアウト, 管理者以上）
         * - TODO: 自分自身の強制ログアウトは禁止（tests要件）
         */
        public async force_logout(userId: string): Promise<{
    /**
     * 公開API: 全セッション無効化（強制ログアウト, 管理者以上）
     * - TODO: 自分自身の強制ログアウトは禁止（tests要件）
     */
    success: boolean

    /**
     * 公開API: 全セッション無効化（強制ログアウト, 管理者以上）
     * - TODO: 自分自身の強制ログアウトは禁止（tests要件）
     */
    "revoked_count": number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/${encodeURIComponent(userId)}/force-logout`)
            return await resp.json() as {
    /**
     * 公開API: 全セッション無効化（強制ログアウト, 管理者以上）
     * - TODO: 自分自身の強制ログアウトは禁止（tests要件）
     */
    success: boolean

    /**
     * 公開API: 全セッション無効化（強制ログアウト, 管理者以上）
     * - TODO: 自分自身の強制ログアウトは禁止（tests要件）
     */
    "revoked_count": number
}
        }

        /**
         * QRトークンを生成する（ユーザー用）
         * ユーザーがこのトークンを含むQRコードを表示し、管理者/受付がスキャンする
         */
        public async generate_qr_token(params: attendance.GenerateQRTokenRequest): Promise<attendance.GenerateQRTokenResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/attendance/qr/generate`, JSON.stringify(params))
            return await resp.json() as attendance.GenerateQRTokenResponse
        }

        public async get_active_qr_token(params: attendance.GetActiveQRTokenRequest): Promise<attendance.GetActiveQRTokenResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                "clock_type": params["clock_type"] === undefined ? undefined : String(params["clock_type"]),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/attendance/qr/active`, undefined, {query})
            return await resp.json() as attendance.GetActiveQRTokenResponse
        }

        /**
         * 有効な打刻方法一覧を取得
         */
        public async get_clock_methods(): Promise<{
    methods: attendance.ClockMethod[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/attendance/clock-methods`)
            return await resp.json() as {
    methods: attendance.ClockMethod[]
}
        }

        /**
         * 顔データの登録状態を取得する（ユーザー用）
         */
        public async get_face_status(): Promise<attendance.FaceDataStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/attendance/face/status`)
            return await resp.json() as attendance.FaceDataStatusResponse
        }

        public async get_my_attendance(params: attendance.GetMyAttendanceRequest): Promise<attendance.AttendanceListResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                from:   params.from,
                limit:  params.limit === undefined ? undefined : String(params.limit),
                offset: params.offset === undefined ? undefined : String(params.offset),
                to:     params.to,
                type:   params.type === undefined ? undefined : String(params.type),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/attendance/me`, undefined, {query})
            return await resp.json() as attendance.AttendanceListResponse
        }

        /**
         * 公開API: 自分のプロフィール取得
         * - users.app_users + roles からプロファイルを構築し、アバターURLは署名URLを動的生成。
         */
        public async get_profile(): Promise<users.UserProfile> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/user-settings/profile`)
            return await resp.json() as users.UserProfile
        }

        /**
         * 今日の打刻状態を取得
         */
        public async get_today_status(): Promise<attendance.TodayStatus> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/attendance/today`)
            return await resp.json() as attendance.TodayStatus
        }

        /**
         * 公開API: ユーザー詳細（管理者以上）
         */
        public async get_user_detail(userId: string): Promise<{
    /**
     * 公開API: ユーザー詳細（管理者以上）
     */
    user: users.UserInfo
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(userId)}`)
            return await resp.json() as {
    /**
     * 公開API: ユーザー詳細（管理者以上）
     */
    user: users.UserInfo
}
        }

        /**
         * 公開API: ユーザーセッション一覧（管理者以上）
         */
        public async get_user_sessions(userId: string): Promise<{
    /**
     * 公開API: ユーザーセッション一覧（管理者以上）
     */
    sessions: any[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(userId)}/sessions`)
            return await resp.json() as {
    /**
     * 公開API: ユーザーセッション一覧（管理者以上）
     */
    sessions: any[]
}
        }

        /**
         * 公開API: ロール一覧（管理者以上）
         */
        public async list_roles(): Promise<{
    /**
     * 公開API: ロール一覧（管理者以上）
     */
    roles: {
        /**
         * 公開API: ロール一覧（管理者以上）
         */
        name: string

        /**
         * 公開API: ロール一覧（管理者以上）
         */
        level: number

        /**
         * 公開API: ロール一覧（管理者以上）
         */
        description: string
    }[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/roles`)
            return await resp.json() as {
    /**
     * 公開API: ロール一覧（管理者以上）
     */
    roles: {
        /**
         * 公開API: ロール一覧（管理者以上）
         */
        name: string

        /**
         * 公開API: ロール一覧（管理者以上）
         */
        level: number

        /**
         * 公開API: ロール一覧（管理者以上）
         */
        description: string
    }[]
}
        }

        /**
         * 公開API: ユーザー一覧（管理者以上）
         * - app DBからロール付きで取得 → authサービスからemail/is_activeをバッチ補完。
         * - totalは全体件数（フィルター条件なし）。
         */
        public async list_users(params: {
    /**
     * 公開API: ユーザー一覧（管理者以上）
     * - app DBからロール付きで取得 → authサービスからemail/is_activeをバッチ補完。
     * - totalは全体件数（フィルター条件なし）。
     */
    page?: number

    /**
     * 公開API: ユーザー一覧（管理者以上）
     * - app DBからロール付きで取得 → authサービスからemail/is_activeをバッチ補完。
     * - totalは全体件数（フィルター条件なし）。
     */
    limit?: number
}): Promise<{
    /**
     * 公開API: ユーザー一覧（管理者以上）
     * - app DBからロール付きで取得 → authサービスからemail/is_activeをバッチ補完。
     * - totalは全体件数（フィルター条件なし）。
     */
    users: users.UserInfo[]

    /**
     * 公開API: ユーザー一覧（管理者以上）
     * - app DBからロール付きで取得 → authサービスからemail/is_activeをバッチ補完。
     * - totalは全体件数（フィルター条件なし）。
     */
    total: number
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit: params.limit === undefined ? undefined : String(params.limit),
                page:  params.page === undefined ? undefined : String(params.page),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/list`, undefined, {query})
            return await resp.json() as {
    /**
     * 公開API: ユーザー一覧（管理者以上）
     * - app DBからロール付きで取得 → authサービスからemail/is_activeをバッチ補完。
     * - totalは全体件数（フィルター条件なし）。
     */
    users: users.UserInfo[]

    /**
     * 公開API: ユーザー一覧（管理者以上）
     * - app DBからロール付きで取得 → authサービスからemail/is_activeをバッチ補完。
     * - totalは全体件数（フィルター条件なし）。
     */
    total: number
}
        }

        /**
         * [公開] 顔認証で打刻を行う（タブレット端末用）
         * 認証不要で、全ユーザーの顔データから検索して認証する
         */
        public async public_verify_face(params: attendance.PublicVerifyFaceRequest): Promise<attendance.PublicVerifyFaceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/public/attendance/face/verify`, JSON.stringify(params))
            return await resp.json() as attendance.PublicVerifyFaceResponse
        }

        /**
         * [公開] QRトークンを検証して打刻を行う（タブレット端末用）
         * 認証不要だが、QRトークン自体が認証の役割を果たす
         */
        public async public_verify_qr_token(params: attendance.VerifyQRTokenRequest): Promise<attendance.VerifyQRTokenResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/public/attendance/qr/verify`, JSON.stringify(params))
            return await resp.json() as attendance.VerifyQRTokenResponse
        }

        /**
         * 顔データを登録する（ユーザー用）
         */
        public async register_face(params: attendance.RegisterFaceRequest): Promise<attendance.RegisterFaceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/attendance/face/register`, JSON.stringify(params))
            return await resp.json() as attendance.RegisterFaceResponse
        }

        /**
         * 公開API: 管理者によるユーザーパスワードリセット（管理者以上）
         * - TODO: newPassword長の検証と「自分自身は不可」のチェック（tests要件）を追加。
         */
        public async reset_password(userId: string, params: {
    /**
     * 公開API: 管理者によるユーザーパスワードリセット（管理者以上）
     * - TODO: newPassword長の検証と「自分自身は不可」のチェック（tests要件）を追加。
     */
    newPassword: string
}): Promise<{
    /**
     * 公開API: 管理者によるユーザーパスワードリセット（管理者以上）
     * - TODO: newPassword長の検証と「自分自身は不可」のチェック（tests要件）を追加。
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/${encodeURIComponent(userId)}/password-reset`, JSON.stringify(params))
            return await resp.json() as {
    /**
     * 公開API: 管理者によるユーザーパスワードリセット（管理者以上）
     * - TODO: newPassword長の検証と「自分自身は不可」のチェック（tests要件）を追加。
     */
    success: boolean
}
        }

        /**
         * 公開API: ユーザー復活（管理者以上）
         */
        public async restore_user(userId: string): Promise<{
    /**
     * 公開API: ユーザー復活（管理者以上）
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/${encodeURIComponent(userId)}/restore`)
            return await resp.json() as {
    /**
     * 公開API: ユーザー復活（管理者以上）
     */
    success: boolean
}
        }

        /**
         * 公開API: 自分のプロフィール更新
         */
        public async update_profile(params: users.UpdateProfileRequest): Promise<users.UserProfile> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/user-settings/profile`, JSON.stringify(params))
            return await resp.json() as users.UserProfile
        }

        /**
         * 公開API: ユーザー更新（管理者以上）
         * - TODO: email形式/必須項目の検証を追加。
         * - NOTE: email更新はauthサービスへ委譲。
         */
        public async update_user(userId: string, params: {
    email?: string
    displayName?: string
    firstName?: string
    lastName?: string
    firstNameRomaji?: string
    lastNameRomaji?: string
    timezone?: string
    language?: string
    roleName?: string
}): Promise<{
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/users/${encodeURIComponent(userId)}`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
}
        }

        /**
         * 公開API: ロール変更（SUPER_ADMINのみ）
         */
        public async update_user_role(userId: string, params: {
    /**
     * 公開API: ロール変更（SUPER_ADMINのみ）
     */
    roleName: string
}): Promise<{
    /**
     * 公開API: ロール変更（SUPER_ADMINのみ）
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/${encodeURIComponent(userId)}/role`, JSON.stringify(params))
            return await resp.json() as {
    /**
     * 公開API: ロール変更（SUPER_ADMINのみ）
     */
    success: boolean
}
        }

        /**
         * 公開API: アバターアップロード（最大1MB, Base64）
         */
        public async upload_avatar(params: {
    data: string
    contentType: string
}): Promise<users.UploadAvatarResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/user-settings/avatar`, JSON.stringify(params))
            return await resp.json() as users.UploadAvatarResponse
        }

        /**
         * 顔認証で打刻する（ユーザー用）
         */
        public async verify_face_and_clock(params: attendance.VerifyFaceRequest): Promise<attendance.VerifyFaceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/attendance/face/verify`, JSON.stringify(params))
            return await resp.json() as attendance.VerifyFaceResponse
        }
    }
}

export namespace auth {
    export interface AuthParams {
        authorization?: string
    }

    export interface LoginParams {
        email: string
        password: string
        "device_name"?: string
        "device_fingerprint"?: string
        "remember_device"?: boolean
        /**
         * フロントから明示的にIP/UAを渡すための任意フィールド（開発・デバッグ用）
         */
        "client_ip"?: string

        "client_user_agent"?: string
        "client_ua_brands"?: {
            brand: string
            version?: string
        }[]
    }

    export interface TokenResponse {
        "access_token": string
        "refresh_token": string
        "expires_in": number
        "token_type": "Bearer"
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.ip_trust_anomalies = this.ip_trust_anomalies.bind(this)
            this.ip_trust_events = this.ip_trust_events.bind(this)
            this.ip_trust_summary = this.ip_trust_summary.bind(this)
            this.login = this.login.bind(this)
            this.logout = this.logout.bind(this)
            this.me = this.me.bind(this)
            this.refresh = this.refresh.bind(this)
        }

        public async ip_trust_anomalies(params: {
    hours?: number
    type?: string
}): Promise<{
    anomalies: {
        "anomaly_type": string
        severity: iptrust.Severity
        "risk_score": number
        "detected_at": string
        "user_id": string | null
        details: any
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                hours: params.hours === undefined ? undefined : String(params.hours),
                type:  params.type,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/auth/security/ip-trust/anomalies`, undefined, {query})
            return await resp.json() as {
    anomalies: {
        "anomaly_type": string
        severity: iptrust.Severity
        "risk_score": number
        "detected_at": string
        "user_id": string | null
        details: any
    }[]
}
        }

        public async ip_trust_events(params: {
    hours?: number
    "user_id"?: string
    ip?: string
    severity?: iptrust.Severity
}): Promise<{
    events: {
        "created_at": string
        "user_id": string
        endpoint: string | null
        "ip_address": string | null
        score: number | null
        severity: iptrust.Severity
        flags: string[]
        "decision_source": string | null
        country: string | null
        city: string | null
        reputation?: {
            "is_vpn"?: boolean
            "is_proxy"?: boolean
            "is_tor"?: boolean
            "is_datacenter"?: boolean
            "threat_types"?: string[]
            "risk_level"?: string
            "risk_score"?: number
        } | null
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                hours:     params.hours === undefined ? undefined : String(params.hours),
                ip:        params.ip,
                severity:  params.severity === undefined ? undefined : String(params.severity),
                "user_id": params["user_id"],
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/auth/security/ip-trust/events`, undefined, {query})
            return await resp.json() as {
    events: {
        "created_at": string
        "user_id": string
        endpoint: string | null
        "ip_address": string | null
        score: number | null
        severity: iptrust.Severity
        flags: string[]
        "decision_source": string | null
        country: string | null
        city: string | null
        reputation?: {
            "is_vpn"?: boolean
            "is_proxy"?: boolean
            "is_tor"?: boolean
            "is_datacenter"?: boolean
            "threat_types"?: string[]
            "risk_level"?: string
            "risk_score"?: number
        } | null
    }[]
}
        }

        public async ip_trust_summary(params: {
    hours?: number
}): Promise<{
    "window_hours": number
    "total_events": number
    "severity_counts": {
        low: number
        medium: number
        high: number
        critical: number
    }
    "by_flag": {
        flag: string
        count: number
    }[]
    "top_ips": {
        ip: string
        count: number
        "avg_score": number
        severity: iptrust.Severity
    }[]
    "country_distribution": {
        country: string | null
        count: number
    }[]
    recent: {
        "created_at": string
        "user_id": string
        endpoint: string | null
        "ip_address": string | null
        score: number | null
        severity: iptrust.Severity
        flags: string[]
        "decision_source": string | null
        country: string | null
        city: string | null
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                hours: params.hours === undefined ? undefined : String(params.hours),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/auth/security/ip-trust/summary`, undefined, {query})
            return await resp.json() as {
    "window_hours": number
    "total_events": number
    "severity_counts": {
        low: number
        medium: number
        high: number
        critical: number
    }
    "by_flag": {
        flag: string
        count: number
    }[]
    "top_ips": {
        ip: string
        count: number
        "avg_score": number
        severity: iptrust.Severity
    }[]
    "country_distribution": {
        country: string | null
        count: number
    }[]
    recent: {
        "created_at": string
        "user_id": string
        endpoint: string | null
        "ip_address": string | null
        score: number | null
        severity: iptrust.Severity
        flags: string[]
        "decision_source": string | null
        country: string | null
        city: string | null
    }[]
}
        }

        /**
         * ログインAPI
         * フロー:
         * 1) email検索→不存在/非アクティブ/未検証/認証失敗を段階的に弾き監査ログ（failed_attempt）を保存。
         * 2) アクティブセッション上限(5)超過時は最古を失効。
         * 3) Access/Refresh生成、セッションINSERT。remember_device=true+fingerprint時はデバイス登録/更新。
         * 4) 監査ログ・リアルタイム活動ログ（SSE用）を保存。
         * 
         * 注意:
         * - 現状IP/UAは取得しておらず null ログ。異常検知も未実行。
         * → FIXME: RawRequest対応化して `detectAnomalies()` 実行、criticalは即失効/deny。
         */
        public async login(params: LoginParams): Promise<TokenResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/login`, JSON.stringify(params))
            return await resp.json() as TokenResponse
        }

        /**
         * 公開API: ログアウト処理。
         * - 認証済みユーザーのリフレッシュトークンを無効化
         * - 活動ログを記録
         */
        public async logout(params: {
    "refresh_token": string
}): Promise<{
    ok: true
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/logout`, JSON.stringify(params))
            return await resp.json() as {
    ok: true
}
        }

        /**
         * 公開API: 自分の認証基本情報を取得
         * - authは認証の基盤のみを返す（id/email）。
         * - プロファイルやロールは users サービス側で取得してください。
         */
        public async me(): Promise<{
    /**
     * 公開API: 自分の認証基本情報を取得
     * - authは認証の基盤のみを返す（id/email）。
     * - プロファイルやロールは users サービス側で取得してください。
     */
    user: {
        /**
         * 公開API: 自分の認証基本情報を取得
         * - authは認証の基盤のみを返す（id/email）。
         * - プロファイルやロールは users サービス側で取得してください。
         */
        id: string

        /**
         * 公開API: 自分の認証基本情報を取得
         * - authは認証の基盤のみを返す（id/email）。
         * - プロファイルやロールは users サービス側で取得してください。
         */
        email: string
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/auth/me`)
            return await resp.json() as {
    /**
     * 公開API: 自分の認証基本情報を取得
     * - authは認証の基盤のみを返す（id/email）。
     * - プロファイルやロールは users サービス側で取得してください。
     */
    user: {
        /**
         * 公開API: 自分の認証基本情報を取得
         * - authは認証の基盤のみを返す（id/email）。
         * - プロファイルやロールは users サービス側で取得してください。
         */
        id: string

        /**
         * 公開API: 自分の認証基本情報を取得
         * - authは認証の基盤のみを返す（id/email）。
         * - プロファイルやロールは users サービス側で取得してください。
         */
        email: string
    }
}
        }

        /**
         * 公開API: リフレッシュトークンでアクセストークンを再発行する。
         * - 入力トークンが見つからない場合、同一ファミリーの全セッションを失効（盗用対策）
         * - 有効期限を検査し、ローテーション（旧失効→新発行）
         * - 活動・監査ログを記録
         */
        public async refresh(params: {
    "refresh_token": string
}): Promise<TokenResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/refresh`, JSON.stringify(params))
            return await resp.json() as TokenResponse
        }
    }
}

export namespace dev_tools {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.auth_info = this.auth_info.bind(this)
            this.bulk_device_operation = this.bulk_device_operation.bind(this)
            this.cleanup_sessions = this.cleanup_sessions.bind(this)
            this.create_prefix = this.create_prefix.bind(this)
            this.delete_objects = this.delete_objects.bind(this)
            this.dev_status = this.dev_status.bind(this)
            this.expire_all_sessions = this.expire_all_sessions.bind(this)
            this.generate_download_url = this.generate_download_url.bind(this)
            this.generate_upload_url = this.generate_upload_url.bind(this)
            this.get_all_devices = this.get_all_devices.bind(this)
            this.get_device_detail = this.get_device_detail.bind(this)
            this.get_object_metadata = this.get_object_metadata.bind(this)
            this.list_available_buckets = this.list_available_buckets.bind(this)
            this.list_objects = this.list_objects.bind(this)
            this.remove_device = this.remove_device.bind(this)
            this.session_stats = this.session_stats.bind(this)
            this.testAuthenticationError = this.testAuthenticationError.bind(this)
            this.testInternalError = this.testInternalError.bind(this)
            this.testNonRetryableBusinessError = this.testNonRetryableBusinessError.bind(this)
            this.testNotFoundError = this.testNotFoundError.bind(this)
            this.testPermissionError = this.testPermissionError.bind(this)
            this.testRetryableBusinessError = this.testRetryableBusinessError.bind(this)
            this.testSuccess = this.testSuccess.bind(this)
            this.testValidationError = this.testValidationError.bind(this)
            this.update_device_trust = this.update_device_trust.bind(this)
        }

        /**
         * 認証情報確認API
         */
        public async auth_info(): Promise<{
    "user_id"?: string
    email?: string
    "session_id"?: string
    "session_created"?: string
    "session_expires"?: string
    "dashboard_auth"?: {
        "header_format": {
            name: string
            value: string
            description: string
        }
        "cookie_format": {
            name: string
            value: string
            description: string
        }
        "curl_sample": string
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/auth_info`)
            return await resp.json() as {
    "user_id"?: string
    email?: string
    "session_id"?: string
    "session_created"?: string
    "session_expires"?: string
    "dashboard_auth"?: {
        "header_format": {
            name: string
            value: string
            description: string
        }
        "cookie_format": {
            name: string
            value: string
            description: string
        }
        "curl_sample": string
    }
}
        }

        /**
         * 一括デバイス操作
         */
        public async bulk_device_operation(params: dev_tools.BulkDeviceOperationParams): Promise<dev_tools.DeviceActionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/dev_tools/devices/bulk`, JSON.stringify(params))
            return await resp.json() as dev_tools.DeviceActionResponse
        }

        /**
         * セッションクリーンアップAPI（auth内部API）
         */
        public async cleanup_sessions(): Promise<dev_tools.CleanupResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/dev_tools/cleanup_sessions`)
            return await resp.json() as dev_tools.CleanupResponse
        }

        public async create_prefix(params: dev_tools.CreatePrefixRequest): Promise<dev_tools.CreatePrefixResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/dev_tools/storage/prefix`, JSON.stringify(params))
            return await resp.json() as dev_tools.CreatePrefixResponse
        }

        public async delete_objects(params: dev_tools.DeleteObjectsRequest): Promise<dev_tools.DeleteObjectsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/dev_tools/storage/delete`, JSON.stringify(params))
            return await resp.json() as dev_tools.DeleteObjectsResponse
        }

        /**
         * 開発ステータスAPI
         */
        public async dev_status(): Promise<dev_tools.DevStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/status`)
            return await resp.json() as dev_tools.DevStatusResponse
        }

        /**
         * 有効期限内の全セッションを期限切れにする（自分以外）
         */
        public async expire_all_sessions(): Promise<dev_tools.ExpireSessionsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/dev_tools/expire_all_sessions`)
            return await resp.json() as dev_tools.ExpireSessionsResponse
        }

        public async generate_download_url(params: dev_tools.GenerateSignedUrlRequest): Promise<dev_tools.GenerateSignedUrlResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/dev_tools/storage/download-url`, JSON.stringify(params))
            return await resp.json() as dev_tools.GenerateSignedUrlResponse
        }

        public async generate_upload_url(params: dev_tools.GenerateUploadUrlRequest): Promise<dev_tools.GenerateSignedUrlResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/dev_tools/storage/upload-url`, JSON.stringify(params))
            return await resp.json() as dev_tools.GenerateSignedUrlResponse
        }

        /**
         * 全デバイス一覧取得
         */
        public async get_all_devices(params: {
    limit?: number
    offset?: number
    filter?: "all" | "trusted" | "untrusted" | "suspicious"
}): Promise<dev_tools.DeviceListResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                filter: params.filter === undefined ? undefined : String(params.filter),
                limit:  params.limit === undefined ? undefined : String(params.limit),
                offset: params.offset === undefined ? undefined : String(params.offset),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/devices`, undefined, {query})
            return await resp.json() as dev_tools.DeviceListResponse
        }

        /**
         * デバイス詳細取得
         */
        public async get_device_detail(params: {
    "device_id": string
    "user_id": string
}): Promise<dev_tools.DeviceDetailResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                "device_id": params["device_id"],
                "user_id":   params["user_id"],
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/devices/detail`, undefined, {query})
            return await resp.json() as dev_tools.DeviceDetailResponse
        }

        public async get_object_metadata(params: dev_tools.ObjectMetadataRequest): Promise<dev_tools.ObjectMetadataResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                bucketId: params.bucketId,
                key:      params.key,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/storage/object`, undefined, {query})
            return await resp.json() as dev_tools.ObjectMetadataResponse
        }

        public async list_available_buckets(): Promise<dev_tools.ListBucketsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/storage/buckets`)
            return await resp.json() as dev_tools.ListBucketsResponse
        }

        public async list_objects(params: dev_tools.ListObjectsRequest): Promise<dev_tools.ListObjectsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                bucketId: params.bucketId,
                limit:    params.limit === undefined ? undefined : String(params.limit),
                prefix:   params.prefix,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/storage/objects`, undefined, {query})
            return await resp.json() as dev_tools.ListObjectsResponse
        }

        /**
         * デバイス削除
         */
        public async remove_device(params: {
    "device_id": string
    "user_id": string
}): Promise<dev_tools.DeviceActionResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                "device_id": params["device_id"],
                "user_id":   params["user_id"],
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/dev_tools/devices/remove`, undefined, {query})
            return await resp.json() as dev_tools.DeviceActionResponse
        }

        /**
         * セッション統計情報API
         */
        public async session_stats(): Promise<dev_tools.SessionStatsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/session_stats`)
            return await resp.json() as dev_tools.SessionStatsResponse
        }

        /**
         * 認証エラーのテスト
         */
        public async testAuthenticationError(): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/error-test/auth`)
            return await resp.json() as {
    message: string
}
        }

        /**
         * システムエラーのテスト（500）
         */
        public async testInternalError(): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/error-test/internal`)
            return await resp.json() as {
    message: string
}
        }

        /**
         * ビジネスロジックエラーのテスト（再試行不可）
         */
        public async testNonRetryableBusinessError(): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/error-test/business-non-retryable`)
            return await resp.json() as {
    message: string
}
        }

        /**
         * リソース不在エラーのテスト
         */
        public async testNotFoundError(): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/error-test/notfound`)
            return await resp.json() as {
    message: string
}
        }

        /**
         * 権限エラーのテスト
         */
        public async testPermissionError(): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/error-test/permission`)
            return await resp.json() as {
    message: string
}
        }

        /**
         * ビジネスロジックエラーのテスト（再試行可能）
         */
        public async testRetryableBusinessError(): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/error-test/business-retryable`)
            return await resp.json() as {
    message: string
}
        }

        /**
         * 正常レスポンスのテスト
         */
        public async testSuccess(): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/error-test/success`)
            return await resp.json() as {
    message: string
}
        }

        /**
         * バリデーションエラーのテスト
         */
        public async testValidationError(): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dev_tools/error-test/validation`)
            return await resp.json() as {
    message: string
}
        }

        /**
         * デバイス信頼度更新
         */
        public async update_device_trust(params: {
    "device_id": string
    "user_id": string
    trusted: boolean
    "trust_score"?: number
}): Promise<dev_tools.DeviceActionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/dev_tools/devices/trust`, JSON.stringify(params))
            return await resp.json() as dev_tools.DeviceActionResponse
        }
    }
}

export namespace notification {
    export interface CreateNotificationRequest {
        category?: NotificationCategory
        source?: string
        userId?: string
        targetUserIds?: string[]
        channelIds?: string[]
        templateId?: string
        subject?: string
        message: string
        variables?: { [key: string]: any }
        priority?: NotificationPriority
        metadata?: { [key: string]: any }
        scheduledAt?: string
        expiresAt?: string
    }

    export interface CreateNotificationResponse {
        id: string
        status: string
        success: boolean
    }

    export type NotificationCategory = "system" | "user_action" | "schedule" | "realtime"

    export type NotificationPriority = "low" | "normal" | "high" | "urgent"

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.createNotification = this.createNotification.bind(this)
            this.streamAdminNotifications = this.streamAdminNotifications.bind(this)
            this.streamUserNotifications = this.streamUserNotifications.bind(this)
        }

        /**
         * `POST /notifications`
         * 
         * - チャネル指定・メッセージ本文などを受け取り通知を生成。
         * - 認証中のユーザーIDを自動補完し、`metadata.initiatedBy` として記録する。
         * - 保存後に Pub/Sub へ流し、delivery レイヤー経由で通知を配信する。
         */
        public async createNotification(params: CreateNotificationRequest): Promise<CreateNotificationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/notifications`, JSON.stringify(params))
            return await resp.json() as CreateNotificationResponse
        }

        public async streamAdminNotifications(method: "GET", body?: RequestInit["body"], options?: CallParameters): Promise<globalThis.Response> {
            return this.baseClient.callAPI(method, `/admin/notifications/stream`, body, options)
        }

        public async streamUserNotifications(method: "GET", body?: RequestInit["body"], options?: CallParameters): Promise<globalThis.Response> {
            return this.baseClient.callAPI(method, `/notifications/stream`, body, options)
        }
    }
}

export namespace attendance {
    export interface AdminClockRequest {
        "user_id": string
        type: AttendanceType
        timestamp?: string
        note?: string
    }

    export interface AttendanceListResponse {
        records: AttendanceRecord[]
        total: number
        from: string
        to: string
    }

    export interface AttendanceRecord {
        id: string
        "user_id": string
        timestamp: string
        type: AttendanceType
        note: string | null
        source: AttendanceSource
        "clock_method_id": string | null
        "verification_data": { [key: string]: any }
        "device_info": DeviceInfo
        "location_data": LocationData
        "created_at": string
        "updated_at": string
        "created_by": string | null
        "updated_by": string | null
    }

    export type AttendanceSource = "USER" | "ADMIN" | "SYSTEM"

    export type AttendanceType = "CLOCK_IN" | "CLOCK_OUT" | "ADJUSTMENT"

    export interface ClockMethod {
        id: string
        code: ClockMethodCode
        name: string
        description: string | null
        "is_active": boolean
        config: { [key: string]: any }
        "created_at": string
        "updated_at": string
    }

    export type ClockMethodCode = "button" | "qr_code" | "face_recognition" | "nfc" | "gps"

    export interface ClockRequest {
        timestamp?: string
        "clock_method_code"?: ClockMethodCode
        "verification_data"?: { [key: string]: any }
        "device_info"?: DeviceInfo
        "location_data"?: LocationData
        note?: string
    }

    export interface ClockRequest {
        timestamp?: string
        "clock_method_code"?: ClockMethodCode
        "verification_data"?: { [key: string]: any }
        "device_info"?: DeviceInfo
        "location_data"?: LocationData
        note?: string
    }

    export interface ClockResponse {
        record: AttendanceRecord
        "clock_method": ClockMethod | null
    }

    export interface DailyAttendance {
        date: string
        "clock_in": string | null
        "clock_out": string | null
        "working_minutes": number
        records: AttendanceRecord[]
    }

    export interface DeleteFaceResponse {
        success: boolean
    }

    export interface DeviceInfo {
        ip?: string
        "user_agent"?: string
        browser?: string
        os?: string
        "device_type"?: "desktop" | "mobile" | "tablet"
    }

    export interface FaceDataStatusResponse {
        "has_face_data": boolean
        "face_count": number
    }

    export interface GenerateQRTokenRequest {
        "clock_type"?: "CLOCK_IN" | "CLOCK_OUT"
        "ttl_seconds"?: number
    }

    export interface GenerateQRTokenResponse {
        token: string
        "qr_data": string
        "expires_at": string
        "clock_type": "CLOCK_IN" | "CLOCK_OUT" | null
    }

    export interface GetActiveQRTokenRequest {
        "clock_type"?: "CLOCK_IN" | "CLOCK_OUT"
    }

    export interface GetActiveQRTokenResponse {
        token: string | null
        "qr_data": string | null
        "expires_at": string | null
        "clock_type": "CLOCK_IN" | "CLOCK_OUT" | null
    }

    export interface GetAdminAttendanceRequest {
        "user_id"?: string
        from: string
        to: string
        type?: AttendanceType
        limit?: number
        offset?: number
    }

    export interface GetMyAttendanceRequest {
        from: string
        to: string
        type?: AttendanceType
        limit?: number
        offset?: number
    }

    export interface GetUserAttendanceDetailRequest {
        year?: number
        month?: number
    }

    export interface LocationData {
        latitude?: number
        longitude?: number
        accuracy?: number
        address?: string
        timestamp?: string
    }

    export interface PublicVerifyFaceRequest {
        descriptor: number[]
        "clock_type": "CLOCK_IN" | "CLOCK_OUT"
        "liveness_check"?: boolean
    }

    export interface PublicVerifyFaceResponse {
        success: boolean
        "user_name"?: string
        confidence?: number
        record?: AttendanceRecord
        error?: string
    }

    export interface RegisterFaceRequest {
        descriptor: number[]
        label?: string
    }

    export interface RegisterFaceResponse {
        id: string
        "user_id": string
        "is_primary": boolean
        "created_at": string
    }

    export interface TodayStatus {
        "user_id": string
        date: string
        status: "NOT_CLOCKED_IN" | "WORKING" | "CLOCKED_OUT"
        "clock_in_record": AttendanceRecord | null
        "clock_out_record": AttendanceRecord | null
        records: AttendanceRecord[]
    }

    export interface UpdateAttendanceRequest {
        timestamp?: string
        type?: AttendanceType
        note?: string
    }

    export interface UserAttendanceDetailResponse {
        "user_id": string
        "display_name": string
        email: string
        year: number
        month: number
        "daily_attendances": DailyAttendance[]
        "month_total_minutes": number
        "month_working_days": number
    }

    export interface UserAttendanceSummary {
        "user_id": string
        "display_name": string
        email: string
        "today_status": "NOT_CLOCKED_IN" | "WORKING" | "CLOCKED_OUT"
        "today_clock_in": string | null
        "today_clock_out": string | null
        "month_total_minutes": number
        "month_working_days": number
    }

    export interface UserAttendanceSummaryListResponse {
        summaries: UserAttendanceSummary[]
        total: number
    }

    export interface VerifyFaceRequest {
        descriptor: number[]
        "clock_type": "CLOCK_IN" | "CLOCK_OUT"
        "liveness_check"?: boolean
    }

    export interface VerifyFaceResponse {
        success: boolean
        confidence?: number
        record?: AttendanceRecord
        error?: string
    }

    export interface VerifyQRTokenRequest {
        token: string
        "clock_type": "CLOCK_IN" | "CLOCK_OUT"
    }

    export interface VerifyQRTokenRequest {
        token: string
        "clock_type": "CLOCK_IN" | "CLOCK_OUT"
    }

    export interface VerifyQRTokenResponse {
        success: boolean
        "user_id"?: string
        "user_name"?: string
        "clock_type"?: "CLOCK_IN" | "CLOCK_OUT"
        record?: AttendanceRecord
        error?: string
    }
}

export namespace dev_tools {
    export interface BucketCapabilities {
        read: boolean
        write: boolean
        destroy: boolean
        createPrefix: boolean
    }

    export interface BucketSummary {
        id: string
        bucketName: string
        label: string
        description?: string
        defaultPrefix?: string
        capabilities: BucketCapabilities
    }

    export interface BulkDeviceOperationParams {
        "device_ids": string[]
        action: "trust" | "untrust" | "remove" | "revoke_sessions"
    }

    export interface CleanupResponse {
        success: boolean
        deleted?: {
            expired: number
            revoked: number
            total: number
        }
        remaining?: {
            total: number
            active: number
        }
        error?: string
        timestamp: string
    }

    export interface CreatePrefixRequest {
        bucketId: string
        prefix: string
    }

    export interface CreatePrefixResponse {
        key: string
    }

    export interface DeleteObjectsRequest {
        bucketId: string
        keys: string[]
    }

    export interface DeleteObjectsResponse {
        deleted: string[]
        failed: {
            key: string
            error: string
        }[]
    }

    export interface DevStatusResponse {
        service: string
        status: string
        version: string
        environment: string
        timestamp: string
    }

    export interface DeviceActionResponse {
        success: boolean
        message: string
        "affected_devices"?: number
        "affected_sessions"?: number
    }

    export interface DeviceDetailResponse {
        device: {
            "device_id": string
            "user_id": string
            "user_email": string
            "device_name": string
            "device_fingerprint"?: string
            trusted: boolean
            "trust_score": number
            "first_seen_at": string
            "last_seen_at": string
        }
        sessions: {
            "session_id": string
            "created_at": string
            "expires_at": string
            "is_active": boolean
            "is_suspicious": boolean
            "ip_address": string
            "user_agent": string
            "geo_location"?: {
                country: string
                city: string
                region: string
            }
        }[]
        "activity_patterns": {
            "common_locations": {
                country: string
                city: string
                frequency: number
            }[]
            "common_times": {
                hour: number
                "day_of_week": number
                frequency: number
            }[]
        }
    }

    export interface DeviceListResponse {
        devices: {
            "device_id": string
            "user_id": string
            "user_email": string
            "device_name": string
            trusted: boolean
            "trust_score": number
            "first_seen_at": string
            "last_seen_at": string
            "sessions_count": number
            "last_location"?: {
                country: string
                city: string
            }
        }[]
        summary: {
            "total_devices": number
            "trusted_devices": number
            "untrusted_devices": number
            "avg_trust_score": number
        }
    }

    export interface DirectoryEntry {
        key: string
        name: string
    }

    export interface ExpireSessionsResponse {
        success: boolean
        affected: number
        message: string
        timestamp: string
    }

    export interface GenerateSignedUrlRequest {
        bucketId: string
        key: string
        ttlSeconds?: number
    }

    export interface GenerateSignedUrlResponse {
        url: string
        expiresIn: number
    }

    export interface GenerateUploadUrlRequest {
        contentType?: string
        bucketId: string
        key: string
        ttlSeconds?: number
    }

    export interface ListBucketsResponse {
        buckets: BucketSummary[]
    }

    export interface ListObjectsRequest {
        bucketId: string
        prefix?: string
        limit?: number
    }

    export interface ListObjectsResponse {
        bucketId: string
        prefix: string
        directories: DirectoryEntry[]
        objects: ObjectEntry[]
    }

    export interface ObjectEntry {
        key: string
        name: string
        size: number
        etag: string
        contentType?: string
    }

    export interface ObjectMetadataRequest {
        bucketId: string
        key: string
    }

    export interface ObjectMetadataResponse {
        key: string
        size: number
        etag: string
        contentType?: string
        version?: string
    }

    export interface SessionStatsResponse {
        summary: {
            "total_sessions": number
            "active_sessions": number
            "expired_sessions": number
            "revoked_sessions": number
            "unique_users": number
            "oldest_session": string | null
            "newest_session": string | null
        }
        "top_users": {
            "user_id": string
            email: string
            "session_count": number
        }[]
        "cleanup_recommendation": {
            "expired_to_clean": number
            "revoked_to_clean": number
        }
    }
}

export namespace iptrust {
    export type Severity = "low" | "medium" | "high" | "critical"
}

export namespace users {
    export interface ChangePasswordRequest {
        "current_password": string
        "new_password": string
    }

    export interface UpdateProfileRequest {
        "display_name"?: string
        "first_name"?: string
        "last_name"?: string
        "first_name_romaji"?: string
        "last_name_romaji"?: string
        timezone?: string
        language?: string
    }

    export interface UploadAvatarResponse {
        "avatar_url": string
        "avatar_bucket_key": string
    }

    export interface UserInfo {
        id: string
        email: string
        "display_name": string | null
        role: string
        "role_level": number
        "is_active": boolean
        "created_at": string
    }

    export interface UserProfile {
        id: string
        email: string
        "display_name": string
        "first_name"?: string
        "last_name"?: string
        "first_name_romaji"?: string
        "last_name_romaji"?: string
        "avatar_url"?: string
        "avatar_bucket_key"?: string
        timezone?: string
        language?: string
        role?: {
            id: string
            name: string
            level: number
        }
    }
}



function encodeQuery(parts: Record<string, string | string[]>): string {
    const pairs: string[] = []
    for (const key in parts) {
        const val = (Array.isArray(parts[key]) ?  parts[key] : [parts[key]]) as string[]
        for (const v of val) {
            pairs.push(`${key}=${encodeURIComponent(v)}`)
        }
    }
    return pairs.join("&")
}

// makeRecord takes a record and strips any undefined values from it,
// and returns the same record with a narrower type.
// @ts-ignore - TS ignore because makeRecord is not always used
function makeRecord<K extends string | number | symbol, V>(record: Record<K, V | undefined>): Record<K, V> {
    for (const key in record) {
        if (record[key] === undefined) {
            delete record[key]
        }
    }
    return record as Record<K, V>
}

function encodeWebSocketHeaders(headers: Record<string, string>) {
    // url safe, no pad
    const base64encoded = btoa(JSON.stringify(headers))
      .replaceAll("=", "")
      .replaceAll("+", "-")
      .replaceAll("/", "_");
    return "encore.dev.headers." + base64encoded;
}

class WebSocketConnection {
    public ws: WebSocket;

    private hasUpdateHandlers: (() => void)[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        let protocols = ["encore-ws"];
        if (headers) {
            protocols.push(encodeWebSocketHeaders(headers))
        }

        this.ws = new WebSocket(url, protocols)

        this.on("error", () => {
            this.resolveHasUpdateHandlers();
        });

        this.on("close", () => {
            this.resolveHasUpdateHandlers();
        });
    }

    resolveHasUpdateHandlers() {
        const handlers = this.hasUpdateHandlers;
        this.hasUpdateHandlers = [];

        for (const handler of handlers) {
            handler()
        }
    }

    async hasUpdate() {
        // await until a new message have been received, or the socket is closed
        await new Promise((resolve) => {
            this.hasUpdateHandlers.push(() => resolve(null))
        });
    }

    on(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.addEventListener(type, handler);
    }

    off(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.removeEventListener(type, handler);
    }

    close() {
        this.ws.close();
    }
}

export class StreamInOut<Request, Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamIn<Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamOut<Request, Response> {
    public socket: WebSocketConnection;
    private responseValue: Promise<Response>;

    constructor(url: string, headers?: Record<string, string>) {
        let responseResolver: (_: any) => void;
        this.responseValue = new Promise((resolve) => responseResolver = resolve);

        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            responseResolver(JSON.parse(event.data))
        });
    }

    async response(): Promise<Response> {
        return this.responseValue;
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }
}
// CallParameters is the type of the parameters to a method call, but require headers to be a Record type
type CallParameters = Omit<RequestInit, "method" | "body" | "headers"> & {
    /** Headers to be sent with the request */
    headers?: Record<string, string>

    /** Query parameters to be sent with the request */
    query?: Record<string, string | string[]>
}

// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API
export type AuthDataGenerator = () =>
  | auth.AuthParams
  | Promise<auth.AuthParams | undefined>
  | undefined;

// A fetcher is the prototype for the inbuilt Fetch function
export type Fetcher = typeof fetch;

const boundFetch = fetch.bind(this);

class BaseClient {
    readonly baseURL: string
    readonly fetcher: Fetcher
    readonly headers: Record<string, string>
    readonly requestInit: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }
    readonly authGenerator?: AuthDataGenerator

    constructor(baseURL: string, options: ClientOptions) {
        this.baseURL = baseURL
        this.headers = {}

        // Add User-Agent header if the script is running in the server
        // because browsers do not allow setting User-Agent headers to requests
        if (!BROWSER) {
            this.headers["User-Agent"] = "dat-attendance-q9vi-Generated-TS-Client (Encore/v1.52.2)";
        }

        this.requestInit = options.requestInit ?? {};

        // Setup what fetch function we'll be using in the base client
        if (options.fetcher !== undefined) {
            this.fetcher = options.fetcher
        } else {
            this.fetcher = boundFetch
        }

        // Setup an authentication data generator using the auth data token option
        if (options.auth !== undefined) {
            const auth = options.auth
            if (typeof auth === "function") {
                this.authGenerator = auth
            } else {
                this.authGenerator = () => auth
            }
        }
    }

    async getAuthData(): Promise<CallParameters | undefined> {
        let authData: auth.AuthParams | undefined;

        // If authorization data generator is present, call it and add the returned data to the request
        if (this.authGenerator) {
            const mayBePromise = this.authGenerator();
            if (mayBePromise instanceof Promise) {
                authData = await mayBePromise;
            } else {
                authData = mayBePromise;
            }
        }

        if (authData) {
            const data: CallParameters = {};

            data.headers = makeRecord<string, string>({
                authorization: authData.authorization,
            });

            return data;
        }

        return undefined;
    }

    // createStreamInOut sets up a stream to a streaming API endpoint.
    async createStreamInOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamInOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamInOut(this.baseURL + path + queryString, headers);
    }

    // createStreamIn sets up a stream to a streaming API endpoint.
    async createStreamIn<Response>(path: string, params?: CallParameters): Promise<StreamIn<Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamIn(this.baseURL + path + queryString, headers);
    }

    // createStreamOut sets up a stream to a streaming API endpoint.
    async createStreamOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamOut(this.baseURL + path + queryString, headers);
    }

    // callTypedAPI makes an API call, defaulting content type to "application/json"
    public async callTypedAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        return this.callAPI(method, path, body, {
            ...params,
            headers: { "Content-Type": "application/json", ...params?.headers }
        });
    }

    // callAPI is used by each generated API method to actually make the request
    public async callAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        let { query, headers, ...rest } = params ?? {}
        const init = {
            ...this.requestInit,
            ...rest,
            method,
            body: body ?? null,
        }

        // Merge our headers with any predefined headers
        init.headers = {...this.headers, ...init.headers, ...headers}

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                init.headers = {...init.headers, ...authData.headers};
            }
        }

        // Make the actual request
        const queryString = query ? '?' + encodeQuery(query) : ''
        const response = await this.fetcher(this.baseURL+path+queryString, init)

        // handle any error responses
        if (!response.ok) {
            // try and get the error message from the response body
            let body: APIErrorResponse = { code: ErrCode.Unknown, message: `request failed: status ${response.status}` }

            // if we can get the structured error we should, otherwise give a best effort
            try {
                const text = await response.text()

                try {
                    const jsonBody = JSON.parse(text)
                    if (isAPIErrorResponse(jsonBody)) {
                        body = jsonBody
                    } else {
                        body.message += ": " + JSON.stringify(jsonBody)
                    }
                } catch {
                    body.message += ": " + text
                }
            } catch (e) {
                // otherwise we just append the text to the error message
                body.message += ": " + String(e)
            }

            throw new APIError(response.status, body)
        }

        return response
    }
}

/**
 * APIErrorDetails represents the response from an Encore API in the case of an error
 */
interface APIErrorResponse {
    code: ErrCode
    message: string
    details?: any
}

function isAPIErrorResponse(err: any): err is APIErrorResponse {
    return (
        err !== undefined && err !== null &&
        isErrCode(err.code) &&
        typeof(err.message) === "string" &&
        (err.details === undefined || err.details === null || typeof(err.details) === "object")
    )
}

function isErrCode(code: any): code is ErrCode {
    return code !== undefined && Object.values(ErrCode).includes(code)
}

/**
 * APIError represents a structured error as returned from an Encore application.
 */
export class APIError extends Error {
    /**
     * The HTTP status code associated with the error.
     */
    public readonly status: number

    /**
     * The Encore error code
     */
    public readonly code: ErrCode

    /**
     * The error details
     */
    public readonly details?: any

    constructor(status: number, response: APIErrorResponse) {
        // extending errors causes issues after you construct them, unless you apply the following fixes
        super(response.message);

        // set error name as constructor name, make it not enumerable to keep native Error behavior
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
        Object.defineProperty(this, 'name', {
            value:        'APIError',
            enumerable:   false,
            configurable: true,
        })

        // fix the prototype chain
        if ((Object as any).setPrototypeOf == undefined) {
            (this as any).__proto__ = APIError.prototype
        } else {
            Object.setPrototypeOf(this, APIError.prototype);
        }

        // capture a stack trace
        if ((Error as any).captureStackTrace !== undefined) {
            (Error as any).captureStackTrace(this, this.constructor);
        }

        this.status = status
        this.code = response.code
        this.details = response.details
    }
}

/**
 * Typeguard allowing use of an APIError's fields'
 */
export function isAPIError(err: any): err is APIError {
    return err instanceof APIError;
}

export enum ErrCode {
    /**
     * OK indicates the operation was successful.
     */
    OK = "ok",

    /**
     * Canceled indicates the operation was canceled (typically by the caller).
     *
     * Encore will generate this error code when cancellation is requested.
     */
    Canceled = "canceled",

    /**
     * Unknown error. An example of where this error may be returned is
     * if a Status value received from another address space belongs to
     * an error-space that is not known in this address space. Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     *
     * Encore will generate this error code in the above two mentioned cases.
     */
    Unknown = "unknown",

    /**
     * InvalidArgument indicates client specified an invalid argument.
     * Note that this differs from FailedPrecondition. It indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     *
     * This error code will not be generated by the gRPC framework.
     */
    InvalidArgument = "invalid_argument",

    /**
     * DeadlineExceeded means operation expired before completion.
     * For operations that change the state of the system, this error may be
     * returned even if the operation has completed successfully. For
     * example, a successful response from a server could have been delayed
     * long enough for the deadline to expire.
     *
     * The gRPC framework will generate this error code when the deadline is
     * exceeded.
     */
    DeadlineExceeded = "deadline_exceeded",

    /**
     * NotFound means some requested entity (e.g., file or directory) was
     * not found.
     *
     * This error code will not be generated by the gRPC framework.
     */
    NotFound = "not_found",

    /**
     * AlreadyExists means an attempt to create an entity failed because one
     * already exists.
     *
     * This error code will not be generated by the gRPC framework.
     */
    AlreadyExists = "already_exists",

    /**
     * PermissionDenied indicates the caller does not have permission to
     * execute the specified operation. It must not be used for rejections
     * caused by exhausting some resource (use ResourceExhausted
     * instead for those errors). It must not be
     * used if the caller cannot be identified (use Unauthenticated
     * instead for those errors).
     *
     * This error code will not be generated by the gRPC core framework,
     * but expect authentication middleware to use it.
     */
    PermissionDenied = "permission_denied",

    /**
     * ResourceExhausted indicates some resource has been exhausted, perhaps
     * a per-user quota, or perhaps the entire file system is out of space.
     *
     * This error code will be generated by the gRPC framework in
     * out-of-memory and server overload situations, or when a message is
     * larger than the configured maximum size.
     */
    ResourceExhausted = "resource_exhausted",

    /**
     * FailedPrecondition indicates operation was rejected because the
     * system is not in a state required for the operation's execution.
     * For example, directory to be deleted may be non-empty, an rmdir
     * operation is applied to a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FailedPrecondition, Aborted, and Unavailable:
     *  (a) Use Unavailable if the client can retry just the failing call.
     *  (b) Use Aborted if the client should retry at a higher-level
     *      (e.g., restarting a read-modify-write sequence).
     *  (c) Use FailedPrecondition if the client should not retry until
     *      the system state has been explicitly fixed. E.g., if an "rmdir"
     *      fails because the directory is non-empty, FailedPrecondition
     *      should be returned since the client should not retry unless
     *      they have first fixed up the directory by deleting files from it.
     *  (d) Use FailedPrecondition if the client performs conditional
     *      REST Get/Update/Delete on a resource and the resource on the
     *      server does not match the condition. E.g., conflicting
     *      read-modify-write on the same resource.
     *
     * This error code will not be generated by the gRPC framework.
     */
    FailedPrecondition = "failed_precondition",

    /**
     * Aborted indicates the operation was aborted, typically due to a
     * concurrency issue like sequencer check failures, transaction aborts,
     * etc.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     */
    Aborted = "aborted",

    /**
     * OutOfRange means operation was attempted past the valid range.
     * E.g., seeking or reading past end of file.
     *
     * Unlike InvalidArgument, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate InvalidArgument if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OutOfRange if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FailedPrecondition and
     * OutOfRange. We recommend using OutOfRange (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OutOfRange error to detect when
     * they are done.
     *
     * This error code will not be generated by the gRPC framework.
     */
    OutOfRange = "out_of_range",

    /**
     * Unimplemented indicates operation is not implemented or not
     * supported/enabled in this service.
     *
     * This error code will be generated by the gRPC framework. Most
     * commonly, you will see this error code when a method implementation
     * is missing on the server. It can also be generated for unknown
     * compression algorithms or a disagreement as to whether an RPC should
     * be streaming.
     */
    Unimplemented = "unimplemented",

    /**
     * Internal errors. Means some invariants expected by underlying
     * system has been broken. If you see one of these errors,
     * something is very broken.
     *
     * This error code will be generated by the gRPC framework in several
     * internal error conditions.
     */
    Internal = "internal",

    /**
     * Unavailable indicates the service is currently unavailable.
     * This is a most likely a transient condition and may be corrected
     * by retrying with a backoff. Note that it is not always safe to retry
     * non-idempotent operations.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     *
     * This error code will be generated by the gRPC framework during
     * abrupt shutdown of a server process or network connection.
     */
    Unavailable = "unavailable",

    /**
     * DataLoss indicates unrecoverable data loss or corruption.
     *
     * This error code will not be generated by the gRPC framework.
     */
    DataLoss = "data_loss",

    /**
     * Unauthenticated indicates the request does not have valid
     * authentication credentials for the operation.
     *
     * The gRPC framework will generate this error code when the
     * authentication metadata is invalid or a Credentials callback fails,
     * but also expect authentication middleware to generate it.
     */
    Unauthenticated = "unauthenticated",
}
